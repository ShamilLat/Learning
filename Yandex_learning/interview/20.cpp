#include <iostream>

struct ListNode {
  int data;
  ListNode* next;
  ListNode(int val) : data(val), next(nullptr) {}
};

ListNode* detectCycle(ListNode* head) {
  if (!head || !head->next) {
    return nullptr;  // Нет цикла, если список пуст или содержит только один
                     // элемент
  }

  ListNode* slow = head;
  ListNode* fast = head;

  while (fast && fast->next) {
    slow = slow->next;  // Перемещаем медленный указатель на один шаг
    fast = fast->next->next;  // Перемещаем быстрый указатель на два шага

    if (slow == fast) {  // Если медленный и быстрый указатели встретились,
                         // значит, есть цикл
      slow = head;  // Возвращаем медленный указатель в начало списка
      while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
      }
      return slow;  // Возвращаем указатель на начало цикла
    }
  }

  return nullptr;  // Нет цикла
}

/*

Док-во решения:
Список имеет вид

{      m       }
• -> • -> • -> • -> • -> •
              /|\       \|/
               • <- • <- •

Пусть в цикле n связей, а в "хвосте" m.
Когда slow указатель пройдет m связей, fast пройдет 2m, => ему останется пройти
n - m связей до конца круга, в то время как slow будет на начале этого круга.
Когда slow пройдёт n - m связей, то fast пройдет 2*(n - m) связей, из которых
n-m до начала круга и n-m после, соответсвенно они пересекутся, т.е. цикл
найден.
Переносим slow в head, ему до начала круга надо пройти снова m.
Т.к. fast прошёл n-m от начала круга, то ему надо пройти m до начала круга.
При движении в цикле на 25-28 строках они оба одновременно пройдут m связей, значит
пересекутся в "голове" цикла.

*/